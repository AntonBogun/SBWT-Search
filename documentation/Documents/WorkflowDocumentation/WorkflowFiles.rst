Workflow Files
==============

This page will go through every file which is not part of the code base but is part of the workflow to have everything running easily.  It is recommended to go through the files themselves if you want more information on how each of them works and get a deeper understanding. Most files also have a sentence at the top explaining their purpose in a deeper manner.

* **root**:

  * `.clang-format`: This is the file used by the clang-format tool, which makes sure that the code base follows a consistent coding style. For those familiar, it is similar to python's flake8. Inside the file we specify how we want our codebase to look. For detailed explanation of each option, the reader is referred to the official documentation which also contains a lot of examples for each option: https://clang.llvm.org/docs/ClangFormatStyleOptions.html. Rather than running clang-format directly, we make use of 2 python scripts: `scripts/cmake_checks/check_clang_format.py` and `scripts/standalone/apply_clang_format.py`.
  * `.clang-tidy`: This is the file used by the clang-tidy tool, which performs static analysis. Inside the file we specify which files to ignore when going through the codebase. Rather than using clang-tidy directly, we make use of a python script: `scripts/cmake_checks/clang_tidy.py`. Note: clang-tidy may fail the first time we run `scripts/build/build_all.sh` since the compilation database would not have been built by then. So when we run it afterwards it will be successful.
  * `.gitignore`: Specifies which files should be ignored by our git repository
  * `CMakeLists.txt`: This is the root CMakeLists which calls all other cmake files. It is used by the cmake tool to build the Makefile which would then be used to compile our program. Inside it, we specify the project name and details, we load all files within the *cmake* folder and then add the src and documentation folder, which also contain a CMakeLists.txt file, as subdirectories, so that the CMakeLists.txt file within them is also executed (sequentially).
  * `README.md`: Opening statement to get users and developers started when using this repository. Everything that normal users need to know should be in the README so that they do not have to go digging elsewhere.
  * **.github/workflows**: A folder required by github to perform github actions

    * `publish-documentation.yml`: This is the file responsible for building the documentation and tests on github and then publishing both the documentation and test results + code coverage as a github page. Within the file, each step has a name which describes its purpose. The website is put inside the docs folder, which is why the `.gitignore` within that folder is removed when we push to github pages since otherwise the website would not be pushed to the *gh-pages* branch.

  * **cmake**: A folder containing cmake files which act as helper functions for cmake

    * `CCache.cmake`: Use ccache if available, which is a tool for caching compilation results
    * `CompilerWarnings.cmake`: Enable a lot of useful compiler warnings based on platform (Windows or Unix)
    * `ExportCompileCommands.cmake`: Generate a file called `compile_command.json` which are the commands used to compile the program. This is used by some language servers to provide autocompletion and code navigation capabilities. We only enable this to be on when we build everything, so that it contains our full compilation database.
    * `Options.cmake`: Contains general compilation options. These include working with Shared Libraries and using Interprocedural Optimisation
    * `PreventBuildingInCmakeDirectory.cmake`: As the name says, this will halt cmake if it realises that it is running within a folder which contains a `CMakeLists.txt`. This makes sure that the developers do not make a mistake when running cmake, since it produces a lot of files. Thus, it makes sure that we are running within some sort of build directory.
    * `StaticAnalyzers.cmake`: Runs the static analysers which are *clang-format* and *clang-tidy*. Does not actually run *cmake-format*, it only shows the user the diff between the files, to prevent any unwanted changes. It also runs a python script which makes sure that there are header guards in the CPP header files.

  * **docs**:

    * `.gitignore`: Ignores any files generated automatically by our documentation and code coverage tools.
    * `index.html`: Front page of our documentation and code coverage website, designed to unify the two.

  * **documentation**: Any files related to documentation will be put here

    * **RST**: This folder is where the files generated by Sphinx after reading from the Doxygen output will be put
      * `.gitignore`: Ignores everything in the folder except for itself
    * **documents**: This is the area where to put any custom documents of Sphinx. For example, this page that you are reading is within the **documents** folder
    * **static**: A folder required by Sphinx for building its html pages
      * `.gitignore`: Ignores everything in the folder except for itself
    * `.gitignore`: ignores unecessary files and folders within this folder
    * `CMakeLists.txt`: Looks for Doxygen and fails if it cannot find it. If it finds it, it will replace any text within the specified files (usually these files will end with the *.in* extension) which is surrounded by *@* by the parameters provided by cmake. For example, if we look at the first line of `documentation/index.rst`, you will notice that part of the title is surrounded by *@*. This part will be replaced by the same value as it is within cmake. The output file is the same file but without the *.in* extension, so that the original file is unmodified. So if the input is *a.txt.in*, the output will be *a.txt*. Look at the *configure_file* cmake command here: https://cmake.org/cmake/help/latest/command/configure_file.html.
    * `Doxyfile.in`: A templace Doxyfile generated by doxygen. Change the settings here as you see fit, however make sure to keep *GENERATE_XML* to *YES*, because this output is used by Sphinx's breathe extension.
    * `Makefile`: Makefile used to make the html generated by Sphinx. This is automatically generated by the Sphinx tool
    * `conf.rst.in`: Sphinx configuration file. This is where we specify the theme, the extensions we wish to use and other options for our website
    * `index.rst.in`: This is the index.html for our documentation site. Inside it we create a table of contents tree with the contents of our website. Each document we add we will need to add here. We can also have sub-trees, so that our documents form a hierarchy.
    * `make.bat`: Windows equivalent of the Makefile

  * **scripts**: This folder contains scripts written in multiple languages which are used to combine multiple commands into a single file. It is advised to only build using these scripts rather than using the individual :ref:`Tools` directly.

    * **build**: Scripts used to build executables and documentation. Within this script, cmake configuration options are set. Change these if you wish to set different options.

      * `all.sh`: Generates compilation database and then calls all other build scripts except for `scripts/build/build_debug.sh`.
      * `docs.sh`: Builds documentation
      * `release.sh`: Builds the main program in release mode
      * `debug.sh`: Builds the main program in debug mode
      * `tests.sh`: Builds the testing executable
      * `verify.sh`: Build the benchmark executable

    * **cmake_checks**

      * `check_clang_format.py`: Clang format by default edits the file that you run it on. Therefore I created this python script which executes clang format on temporary files and then returns the difference between them using git diff. This way no file is changed without
      * `check_header_guards.py`: Clang format by default edits the file that you run it on. Therefore I created this python script which executes clang format on temporary files and then returns the difference between them using git diff. This way no file is changed without
      * `clang-tidy.py`: clang-tidy needs us to input files to its command manually, therefore this script handles that. It will run over all our non-test and point out any potential unsafe code in the shell output. It uses the compilation commands `compile_commands.json` in the root directory, which are generated when we run `scripts/build/build_all.sh`.

    * **configure**: Files to set some dependencies before running other scripts

      * `download_benchmark_data.sh`: Download the files used for benchmarking

    * **sbatch**: Scripts which are meant to be run using slurm configured systems.

      * `run_benchmarks.sbatch`: Build and run the benchmark main. It calls `scripts/standalone/run_benchmarks.sh` to do the actual benchmarking work

    * **standalone**: These are scripts that run things and generate outputs

      * `apply_clang_format.py`: Applies the changes proposed by clang format. Warning: This actually changes the source code. While it would not change the contents, make sure that you agree with the changes (you can check what changes will be applied if you run `./scripts/cmake_checks/check_clang_format.py`
      * `apply_iwyu.py`: Apply Include-What-You-Use on the provided files
      * `test.sh`: Runs the tests and generates html so that code coverage can easily be seen in the docs.
      * `benchmark.sh`: Script called by `./scripts/sbatch/benchmarks.sbatch` to actually do the work of running the benchmarks.
      * `benchmark.sh`: Run benchmark
      * `analyse_benchmark_results.py`: Python script to produce a timeline and table of the time spent on each component when running the program. This reads the logs generated by the benchmarks
      * `graph_benchmark_results.py`: Show a graph of the benchmarks with different batches for different inputs and different batches

  * **src**:

    * `main.cpp`: Where the main function of the actual program executable resides.
    * `test_main.cpp`: Where main function for the googletest's executable resides. Usually this file is not modified
    * `BuildCommon.cmake`: Builds any files which will be used by multiple programs
    * `BuildMain.cmake`: Builds the main executable for all platforms (CUDA, CPU, etc), linking other libraries and setting options along the way
    * `BuildTests.cmake`: Loads googletest into the repository as a dependency and builds the test executable, linking other libraries and setting options along the way
    * `BuildBenchmark.cmake`: Builds the benchmark executable, linking other libraries and setting options along the way
    * `BuildVerify.cmake`: Builds the verification executable, linking other libraries and setting options along the way
    * `CMakeLists.txt`: Tells cmake to execute the other *.cmake* files in this folder.
